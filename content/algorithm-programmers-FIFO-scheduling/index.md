---
emoji: 🤔
title: "[프로그래머스] 선입 선출 스케줄링 풀이"
date: "2022-01-19 10:14:00"
author: 얌얌냥이
tags: 알고리즘 프로그래머스 이분 탐색 풀이 선입선출 스케줄링 자바스크립트 
categories: algorithm
---

## **✏️** 문제

---

처리해야 할 동일한 작업이 n 개가 있고, 이를 처리하기 위한 CPU가 있습니다.

이 CPU는 다음과 같은 특징이 있습니다.

- CPU에는 여러 개의 코어가 있고, 코어별로 한 작업을 처리하는 시간이 다릅니다.
- 한 코어에서 작업이 끝나면 작업이 없는 코어가 바로 다음 작업을 수행합니다.
- 2개 이상의 코어가 남을 경우 앞의 코어부터 작업을 처리 합니다.

처리해야 될 작업의 개수 n과, 각 코어의 처리시간이 담긴 배열 cores 가 매개변수로 주어질 때, 마지막 작업을 처리하는 코어의 번호를 return 하는 solution 함수를 완성해주세요.

### **🚨** 제한사항

- 코어의 수는 10,000 이하 2이상 입니다.
- 코어당 작업을 처리하는 시간은 10,000이하 입니다.
- 처리해야 하는 일의 개수는 50,000개를 넘기지 않습니다.

### 📌 입출력 예시

---

| n | cores | result |
| --- | --- | --- |
| 6 | [1,2,3] | 2 |

## **🤔** 풀이 코드

---

```jsx
function solution(n, cores) {
    let low = 1;
    let high = Math.max(...cores)*n;
    let check = 0;
    let mid;
    let newN = n - cores.length;
    
    if(cores.length >= n) return n; 
    
    while(low < high){
        mid = Math.floor((low+high)/2); 
        check = 0;
        cores.forEach(core => {
            check += (Math.floor(mid/core));
        })
        if(check < newN){ // 넣을 수 있는 개수가 newN보다 작으면 time의 범위가 더 커져야 한다.
            low = mid+1;
        }else{
            high = mid; // 이때는 check가 더 커서 Time을 줄여주어야하는 경우.
        }
    }
    let cnt = 0;
    cores.forEach(core => {
        cnt += Math.floor((low-1)/core);
    })
    
    for(let i = 0; i < cores.length; i++){
        if((low)%cores[i] === 0){
            cnt++;
            if(cnt === newN) return i+1;
        }
    }
}
```

## 😼 나의 풀이과정

---

처음에 풀었던 방식은 위 풀이와 비슷한 듯 달랐습니다. `n`이 들어가는 시간을 구하기 위해서 선형적으로 풀었습니다. `while`문을 돌면서 `time`을 더해가면서 그 시간까지 각각의 코어에 넣을 수 있는 개수를 배열로 가지고 있으면서 값을 갱신해나가는 식으로 했었습니다. `cores[i]`로 나눈 나머지가 `0`인 경우, 해당 시간에 그 코어에 작업을 할당시킬 수 있으므로 배열의 i번째 값을 `cores[i]`만큼 더해주었습니다. 그러다가 그 배열안의 모든 값의 합이 `n`과 같아질 때, 그때의 `i+1`이 답이 되었습니다. 이렇게 풀면 코드도 간단하고 이해하기도 좋았지만 효율성 테스트를 모두 통과하지 못했습니다.

적절한 시간을 빠르게 찾아야 했습니다. 그래서 이분 탐색을 사용하였습니다. 찾고자 하는 `n`이 코어 배열의 크기보다 작으면 `n` 그 자체로 답이 됩니다. 이는 시간이 `0`일 때입니다. 그렇지 않으면 `n`에서 코어 배열의 크기를 뺀 개수 `(newN)`를 가지고 처리를 할 것입니다. `low`는 시간 `1`, `high`는 `최대로 걸릴 수 있는 시간`을 설정해두고 `low`와 `high`의 중간 값인 `mid` 시간을 사용합니다. 모든 코어가 걸릴 수 있는 작업 시간으로 `mid`를 나눈 몫을 다 더합니다. `(check)`. 이는 `mid`까지 모든 코어가 처리할 수 있는 작업의 개수를 뜻합니다. 이 개수가 `newN`보다 작으면 시간이 더 커져서 더 작업을 처리해야한다는 의미이므로 `low`를 `mid+1`로 갱신하여 뒤쪽 절반의 범위로 줄여 탐색합니다. `newN`보다 크면 시간이 너무 크다는 의미이므로 `high`를 `mid`로 줄여줍니다. 이 절차를 `low < high` 일 때까지 반복을 합니다. `low`가 `high`와 같아지는 순간 `while`문에서 탈출할 것입니다. low 또는 `high`의 시간보다 `1시간 적을 때까지` 각 코어들이 처리할 수 있는 개수를 `cnt`에 저장하고, `low` 또는 `high`의 시간이 되었을 때, `low` 또는 `high`를 `cores[i]`로 나눈 나머지가 0이라면 작업을 할당할 수 있다는 의미이므로 `cnt`를 더해줍니다. `cnt`가 `newN`과 같아지면 그 때의 `i+1`을 답으로 리턴하도록 하였습니다. 

## ✨ 알게된 점

---

- 이분 탐색을 이렇게도 활용할 수 있구나를 느낌
- 선형적으로 풀지 못하면 분명 다른 길이 있음을 알아채야 함
- 이분 탐색 인덱스 주의!

```toc

```
