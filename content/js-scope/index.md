---
emoji: 🔗
title: "스코프"
date: "2022-01-26 15:36:00"
author: 얌얌냥이 
tags: javascript scope 렉시컬 환경 렉시컬 스코프 var let const 
categories: javascript
---

## 자바스크립트의 스코프(유효 범위)
---

다른 언어의 스코프와 구별되는 특징이 있으므로 주의해야한다. 

아래 코드를 보면 마지막 줄에서 레퍼런스 에러가 발생하는 데, 이유는 `매개변수의 스코프`가 `함수 몸체 내부`이기 때문이다.

```javascript
function add(x,y){
	console.log(x,y);
	return x+y;
}
add(1,2);
console.log(x,y) // reference error
```

모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 **`선언된 위치`**에 따라 참조할 수 있는 범위가 결정된다. 

> ***스코프 = 식별자가 유효한 범위***
> 

```javascript
var x = 'global';
function foo(){
	var x = 'local';
	console.log(x); // local
}
foo();
console.log(x); // global
```

자바스크립트 엔진은 위의 코드를 실행하면서 선언된 두 개의 x 변수 중 어떤 것을 참조할 것인지 `식별자를 결정`한다. 이때 `코드의 문맥(Context)`를 고려한다. 

> ***스코프 = 식별자를 검색할 때 사용하는 규칙***
> 

### 📌 코드의 문맥과 환경

- 렉시컬 환경(lexical environment): 코드가 어디서 실행되며 주변에 어떤 코드가 있는지
- 코드의 문맥은 렉시컬 환경으로 이루어짐
- 이를 구현한 실제가 실행 컨텍스트(execution context), 모든 코드는 실행 컨텍스트에서 평가되고 실행됨

### 📌 식별자

변수나 함수 이름, 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다. 

하나의 값이 유일한 식별자와 연결이 된다.

### 📌 폴더의 개념

컴퓨터에서 파일의 이름은 식별자로 고유해야 한다. 하지만 폴더라는 개념을 통해 전체 컴퓨터에서 다른 폴더에서 파일의 이름을 중복해서 사용할 수 있다. 이 예시와 마찬가지로 자바스크립트에서는 하나의 스코프 내에서만 식별자가 유일하면 된다. 위 코드에서 두 x 변수는 이름이 동일한 식별자이지만 스코프가 다른 별개의 변수이다. 

> ***스코프 = 네임 스페이스***
> 

### 📌 var 🆚 let,const

var 키워드로 선언된 변수는 `동일 스코프 내에서 중복선언이 가능`하다. 이 때문에 의도치 않게 변수값이 재할당되어 변경되는 부작용이 발생할 수 있다.

이에 반해, let과 const는 `동일 스코프 내에 중복선언을 허용하지 않는다`.

## 스코프의 종류
---

| 전역 | 코드 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| --- | --- | --- | --- |
| 지역 | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |

전역 변수는 어디서든지 참조할 수 있다.

지역 스코프는 자신의 지역 스코프와 하위 지역스코프 내에서 유효하다.

## 스코프 체인
---

중첩함수: 함수 몸체 내부에 정의한 함수 

외부함수: 중첩함수를 포함하는 함수

스코프는 함수의 중첩에 의해 계층적인 구조를 가진다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 상위 스코프로 이동하여 선언된 변수를 검색한다.

⇒ 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조가 불가능 (상속과 유사하다.)

`스코프 체인`은 물리적인 실체로 존재한다. 자바스크립트 엔진은 코드를 실행하기 전, `렉시컬 환경`을 실제로 생성한다. `변수 선언`이 실행되면 `변수 식별자`가 `렉시컬 환경(자료 구조)`에 `키`로 등록되고, `변수 할당`이 일어나면 이 자료구조의 `변수 식별자에 해당하는 값을 변경`한다. `변수의 검색`도 이 자료구조에서 일어난다. 

### 📌 렉시컬 환경

스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다. 

- 전역 렉시컬 환경: 코드가 로드되면 곧바로 생성
- 함수 렉시컬 환경: 함수가 호출되면 곧바로 생성

```javascript
function foo(){
	console.log('global function foo');
}

function bar(){
	function foo(){
		console.log('local function foo');
	}
	foo(); //1
}
bar();
```

자바스크립트 엔진은 런타임 이전에 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 위 코드에서 모든 함수는 함수 이름과 동일한 이름의 식별자에 할당된다. 

1번에서 foo를 호출하면 자바스크립트는 식별자 foo를 검색하는데, 함수도 식별자이므로 스코프를 가진다. 

⇒ **스코프**는 변수 검색에 사용하는 규칙보다는 **식별자를 검색하는 규칙**

## 함수 레벨 스코프
---

### 📌 블록 레벨 스코프

함수 몸체 뿐만 아니라 모든 코드 블록에서 지역 스코프를 만드는 특성. 대부분의 프로그래밍 언어가 이 특성을 가지고 있음

### 📌 함수 레벨 스코프

오직 함수의 코드블록만을 지역스코프로 인정하는 특성

```javascript
var x = 1;

if(true){
	var x = 10
}

console.log(x); // 10
```

위 코드를 보면 `var 키워드`로 선언된 변수는 `함수의 코드 블록`만을 지역 스코프로 인정하므로 코드 블록 내에서 선언되었다 할지라도 전역 변수가 된다. var는 또한 let, const와 다르게 동일 스코프에서 중복 선언이 허용이 되므로 변수 값이 변경되는 부작용이 발생해 console.log()로 10이 출력되는 것을 확인할 수 있다.

**let, const는 블록레벨 스코프를 지원한다.** 

## 렉시컬 스코프(lexical scope)
---

```javascript
var x = 1; 

function foo(){
	var x = 10;
	bar();
}

function bar(){
	console.log(x);
}
foo();
bar();
```

- 함수를 어디서 호출했는지에 따라 상위 스코프 결정 ⇒ 동적 스코프
- 함수를 어디서 정의했는지에 따라 상위 스코프 결정 ⇒ 렉시컬 스코프, 정적 스코프

자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

bar 함수의 상위 스코프는 전역 스코프이므로 `1이 두번 출력`된다.

자바스크립트는 `렉시컬 스코프`를 따르므로 `함수를 어디서 정의했는지`에 따라 상위 스코프를 `정적으로` 결정하며 호출된 위치는 상관이 없다. **함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.** 

함수 정의가 실행되어 생성된 함수 객체는 결정된 상위 스코프를 기억해 함수가 호출될 때마다 기억한 상위 스코프를 참조한다.

```toc

```
