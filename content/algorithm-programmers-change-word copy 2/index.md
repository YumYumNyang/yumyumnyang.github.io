---
emoji: 😈
title: "[프로그래머스] 불량사용자 풀이"
date: "2022-01-16 20:55:00"
author: 얌얌냥이
tags: 알고리즘 프로그래머스 불량사용자 dfs 자바스크립트 
categories: algorithm
---


## **✏️** 문제

---

개발팀 내에서 이벤트 개발을 담당하고 있는 "무지"는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 `불량 사용자`라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 "프로도" 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 '*' 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 '*' 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 '*' 문자를 사용하였습니다."무지"와 "프로도"는 불량 사용자 목록에 매핑된 응모자 아이디를 `제재 아이디` 라고 부르기로 하였습니다.

이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.

### **🚨** 제한사항

- user_id 배열의 크기는 1 이상 8 이하입니다.
- user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.
    - 응모한 사용자 아이디들은 서로 중복되지 않습니다.
    - 응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.
- banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.
- banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.
    - 불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 '*' 로만 이루어져 있습니다.
    - 불량 사용자 아이디는 '*' 문자를 하나 이상 포함하고 있습니다.
    - 불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.
- 제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.

### 📌 입출력 예시

---

| user_id | banned_id | result |
| --- | --- | --- |
| ["frodo", "fradi", "crodo", "abc123", "frodoc"] | ["fr*d*", "abc1**"] | 2 |
| ["frodo", "fradi", "crodo", "abc123", "frodoc"] | ["*rodo", "*rodo", "******"] | 2 |
| ["frodo", "fradi", "crodo", "abc123", "frodoc"] | ["fr*d*", "*rodo", "******", "******"] | 3 |

## **🤔** 풀이 코드

---

```jsx
function solution(user_id, banned_id) {
  let result = [];
  function dfs(remain, banned, visited) {
    if (banned.length === 0) {
      result.push(visited);
      return 1;
    } else {
      for (let k = 0; k < remain.length; k++) {
        if (remain[k].length === banned[0].length) {
          let flag = true;
          for (let i = 0; i < banned[0].length; i++) {
            if (banned[0][i] !== "*" && banned[0][i] !== remain[k][i]) {
              flag = false;
              break;
            }
          }
          if (flag) {
            dfs(
              [...remain.slice(0, k), ...remain.slice(k + 1)],
              banned.slice(1),
              [...visited, remain[k]]
            );
          }
        }
      }
      return 0;
    }
  }
  let visited = [];
  dfs(user_id.slice(), banned_id.slice(), visited);
  let answer = new Set(
    result.map((candidate) => JSON.stringify(candidate.sort()))
  );
  return answer.size;
}
```

## 😼 나의 풀이과정

---

처음에 생각했던 풀이는 먼저 banned_id 마다 매칭되는 user_id 배열을 가지고 각 배열 중 하나의 원소를 뽑아 조합한 것으로 풀면되지않을까 라는 생각을 했습니다. 하지만 banned_id가 중복인 경우도 있었고, 뽑은 원소가 중복인 경우도 있었습니다. 그러면 하나씩 뽑은 모든 조합에서 뽑은 원소가 중복인 경우을 제외하고, 모두 같은 원소들을 가지고 있어 경우가 중복인 경우를 제외를 하자고 생각했습니다. 그래서 먼저 곱집합을 구했습니다. 곱집합을 구하면서 이미 뽑은 원소를 가지고 있는 경우 추가하지 않는 식으로 하였습니다. (뽑은 원소가 중복인 경우) 그런데 이런 경우는 곱집합을 구했을 때, banned_id의 길이보다 작다는 특징이 있습니다. 그래서 banned_id 길이와 같은 것들만 골라 낸 후에, 같은 원소들을 가지고 있는 경우를 제외하고자 각각을 정렬한 다음 모두 JSON.stringify를 해주어 (배열은 Set에 넣을 수 없기 때문) Set에 넣어주었습니다. 그러면 중복된 경우를 뺀 것들만 남게됩니다. 하지만 하나의 테스트 케이스에서 시간 초과가 떴습니다. 

이렇게 억지로 푸는게 맞는 걸까 생각이 되어서 문제의 의도가 무엇인지 고민해보았습니다. 모든 경우를 찾아내는 것이 문제인데 이때 완전탐색을 사용하면 되지 않을까 생각했습니다.. 
두번째 풀이는 그래서 dfs를 사용하였습니다. dfs는 재귀함수를 사용하여 구현하였습니다. 


dfs 함수는 remain이라는 남은 유저 아이디 배열과, banned라는 남은 제재 아이디 배열, visited라는 방문 원소들의 배열을 들고있습니다. 

남은 제재 아이디 배열의 길이가 0이면, 즉 빈 배열이면 이때까지 방문했던 visited 배열을 하나의 경우로써 result에 추가해준다. 0이 아닌 경우에는 남은 유저 아이디 배열을 순회하면서, 만약 한 유저 아이디가 남은 제재  아이디배열의 가장 첫 원소와 길이가 같다면 매칭되는지 살펴봅니다. 만약에 매칭이 되는 경우(flag가 참) 또 다시 dfs를 부르는데, 이때 remain에는 그 유저 아이디를 제외한 배열을, banned에는 banned의 첫번째 원소를 제외한 배열을, visited에는 그 유저아이디를 추가해준 것을 매개변수로써 넘겨줍니다. 순회가 모두 끝나면 종료합니다. 이렇게 하면 banned_id 배열과 매칭되는 모든 경우를 구할 수 있는데, 각각의 경우에서 정렬 후에 JSON.stringify를 해서 Set에 넣어주는 방식으로 첫번째 풀이와 동일하게 마무리하였다. 답은 Set의 사이즈가 됩니다. 

## ✨ 알게된 점

---

- dfs 접근을 어떻게 해야할지 조금은 감이 잡힌 것 같다. 다른 문제를 좀 더 풀어봐야겠다.
- 생각을 게으르게 하지 말자. 구현해야할 것은 구현해야한다.
- 배열의 중복을 없애기 위해 string으로 바꿔서 Set 객체에 넣어주는 방식에 대해 알게되었다.

```toc

```
